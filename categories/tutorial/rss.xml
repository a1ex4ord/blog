<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="/xsl/rss.xsl"?><rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>教程 - 分类 - zu1k</title><link>https://zu1k.com/categories/tutorial/</link><description>我不想写教程，但是这个栏目确实是教程</description><language>zh-CN</language><managingEditor>i@zu1k.com (zu1k)</managingEditor><webMaster>i@zu1k.com (zu1k)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><atom:link href="https://zu1k.com/categories/tutorial/" rel="self" type="application/rss+xml"/><item><title>IPFS 日用优化指南</title><link>https://zu1k.com/posts/tutorials/p2p/ipfs-easy-use/</link><pubDate>Mon, 06 Jun 2022 23:14:00 +0800</pubDate><author>zu1k</author><guid>https://zu1k.com/posts/tutorials/p2p/ipfs-easy-use/</guid><description><![CDATA[<p>这两天，V2EX 的站长 Livid <a href="https://v2ex.com/t/857404" target="_blank" rel="noopener noreffer" class="post-link">发布了</a> 一款基于 IPFS 和 ENS 的内容发布和订阅应用 <a href="https://planetable.xyz/" target="_blank" rel="noopener noreffer" class="post-link">[Planet]</a>，其想法在之前的一期 <a href="https://fyfy.fm/episode/67" target="_blank" rel="noopener noreffer" class="post-link">[播客访谈]</a> 中就提到过，当初就觉得很有意思。也不出我所料，Planet 一经发布就引来了众多关注，Planet 用图形化的方式使更多普通人可以尝试 IPFS 这类分布式内容发布，据说后面还会增加评论功能，这在 IPFS 网络中也算是一个不小的挑战，不知道 Planet 能将易用性做到什么水平，我会继续关注。</p>
<p>我也在很早之前就了解并开始使用 IPFS 技术，在折腾的过程中也积累了一些经验，下面我将向你们分享一些使用技巧，使你的 IPFS 更加易用。</p>
<blockquote>
<p>完全新手朋友请先阅读我在 20年写的 <a href="../ipfs/" rel="" class="post-link">《IPFS 新手指北》</a> 这篇文章</p>
</blockquote>
<h2 id="搭建网关"><a href="#搭建网关" class="header-mark headerLink">搭建网关</a></h2>
<p>相比较使用公共 IPFS 网关，我更推荐自己在家中搭建，不仅能提供更优的体验，还可以避免在每台电脑安装 IPFS 的麻烦。</p>
<p>按照普通教程在服务器上安装好 IPFS 后，你需要修改配置文件，对外开放 Api 和 Gateway。</p>
<blockquote>
<p>因为是在家庭网络中，我就不额外介绍访问控制配置，如果你是在公网服务器搭建，需要注意配置访问控制以免被滥用</p>
</blockquote>
<p>修改 API 和 Gateway 绑定的 IP 为 <code>0.0.0.0</code> 以开放给局域网，然后修改 API 的 http header 配置跨域：</p>
<div class="highlight"><div class="chroma">
<div class="table-wrapper"><table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="s2">&#34;API&#34;</span><span class="err">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;HTTPHeaders&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;Access-Control-Allow-Headers&#34;</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">      <span class="s2">&#34;X-Requested-With&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="s2">&#34;Range&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="s2">&#34;User-Agent&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;Access-Control-Allow-Methods&#34;</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">      <span class="s2">&#34;GET&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="s2">&#34;POST&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="s2">&#34;OPTIONS&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;Access-Control-Allow-Origin&#34;</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">      <span class="s2">&#34;*&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="p">]</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table></div>
</div>
</div><p>配置子域名网关，可以达到 <code>dweb.link</code> 的效果。例如要使用 <code>*.ipfs.zu1k.com</code> 作为子域名网关，就要先将泛域名解析到 IPFS 网关的 IP，然后在 Gateway 配置中增加以下内容：</p>
<div class="highlight"><div class="chroma">
<div class="table-wrapper"><table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="s2">&#34;Gateway&#34;</span><span class="err">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;PublicGateways&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;ipfs.zu1k.com&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;NoDNSLink&#34;</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;Paths&#34;</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;/ipfs&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;/ipns&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;/api&#34;</span>
</span></span><span class="line"><span class="cl">      <span class="p">],</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;UseSubdomains&#34;</span><span class="p">:</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table></div>
</div>
</div><p>为获得更好的 IPFS 使用体验，推荐安装 <a href="https://chrome.google.com/webstore/detail/ipfs-companion/nibjojkomfdiaoajekhjakgkdhaomnch" target="_blank" rel="noopener noreffer" class="post-link">[IPFS 浏览器插件]</a>，或者使用 Brave 浏览器，可以让 IPFS 的使用体验更加原生。</p>
<h2 id="pin-优化"><a href="#pin-优化" class="header-mark headerLink">Pin 优化</a></h2>
<p>在发布内容后，马上通过公开的 IPFS 网关访问，通常会很慢很慢，甚至到超时都无法访问，这是由 IPFS 的寻址过程导致的。随着访问内容的用户越来越多，他们的 IPFS 节点上会缓存你内容的数据，这个时候新节点再访问同一份内容，通常就会很快。这就是 IPFS 的特性，就跟 BT 下载的原理类似，数据在网络中存在的副本越多，就越能利用 P2P 网络的性能。</p>
<p>但是一个 IPFS 节点也不会无限期的缓存你的数据，默认配置下 GC 频率是 1 个小时一次，也就是说你的数据如果用户不访问，在一个小时后就会从他们的节点中被清理掉。为了能够让我们的数据长久的留在 IPFS 网络中，就需要用户 Pin 住你的数据，以防被 GC 掉。我的做法是利用闲置的服务器搭建 IPFS 节点用来 Pin 自己的数据，然后朋友之间互相 Pin 住，算是合作共赢。</p>
<p>所以大家不妨 Pin 一下我的博客：<code>ipfs pin add /ipns/zu1k.com</code></p>
<p>如果你使用 IPNS 或者域名的方式对外公开经常修改的内容，就需要设置定时任务来不断 Pin 住新的数据，因为 IPFS 在 Pin 一个 IPNS 的时候，只会 Pin 当前状态对应的 CID ，后面不会自己去更新。</p>
<h3 id="remote-pinning-service"><a href="#remote-pinning-service" class="header-mark headerLink">Remote Pinning Service</a></h3>
<p>如果你不想一直运行本机的 IPFS 节点，但又想让别人可以访问到你发布的内容，可以考虑使用 Remote Pinning service，这是由一些中心化的服务商提供的内容 Pinning 服务，其效果与你本机 pin 相当。甚至因为他们的网络质量更好、连接的节点更多，将内容 Pin 在他们的节点上，可以更快的被分发和访问。</p>
<p>我主要推荐两家，<a href="https://www.pinata.cloud/" target="_blank" rel="noopener noreffer" class="post-link">[Pinata]</a> 和 <a href="https://web3.storage/account/" target="_blank" rel="noopener noreffer" class="post-link">[web3.storage]</a>，具体教程可以看 <a href="https://docs.ipfs.io/how-to/work-with-pinning-services/#use-an-existing-pinning-service" target="_blank" rel="noopener noreffer" class="post-link">官方文档</a></p>
<div class="highlight"><div class="chroma">
<div class="table-wrapper"><table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># ipfs pin remote service ls</span>
</span></span><span class="line"><span class="cl">Pinata       https://api.pinata.cloud/psa
</span></span><span class="line"><span class="cl">web3_storage https://api.web3.storage
</span></span></code></pre></td></tr></table></div>
</div>
</div><p>Pinata 是无门槛的，免费提供 1G 的 Pin 容量。</p>
<p>web3.storage 免费提供 1T，但是 Pin Api 需要发邮件申请，一天以内就会有回复。<a href="https://web3.storage/docs/how-tos/pinning-services-api/" target="_blank" rel="noopener noreffer" class="post-link">[教程]</a></p>
<h3 id="开放端口"><a href="#开放端口" class="header-mark headerLink">开放端口</a></h3>
<p>因为 IPFS 需要 P2P 通讯，所以如果你没有公网的 IPFS 节点 Pin 你的内容，就需要保证自己本机的 IPFS 节点可被访问。检查你的路由器，开启 UPnP 功能，必要时建立端口映射，开放你的 4001 端口（如果没有修改过的话）。</p>
<p>




    
        
        
        
        
    
<img
        
        src="/posts/tutorials/p2p/ipfs-easy-use/nat-mapping_huc68249edc18ae4d99b6de292707b695f_10157_789x82_resize_q75_h2_box_3.webp"
        alt="/posts/tutorials/p2p/ipfs-easy-use/nat-mapping_huc68249edc18ae4d99b6de292707b695f_10157_789x82_resize_q75_h2_box_3.webp"
        title="NAT 端口映射"
         height="82"
         width="789"
        loading="lazy"
    /></p>
<h2 id="资源占用优化"><a href="#资源占用优化" class="header-mark headerLink">资源占用优化</a></h2>
<p>如果你没有做任何的配置优化，只是按照常规流程下载安装运行，你会发现 IPFS 在后台会占用大量的 CPU 资源和内存，你的风扇开始狂转；维持了大量的网络连接，导致你的网络卡顿。这是因为 IPFS 的默认配置并没有针对个人小主机进行优化，如果你在一台 2 核的 Linux 服务器上运行，IPFS 甚至能吃满你所有的 CPU，网络的拥挤程度有可能使你连 ssh 登录都成了一个问题。</p>
<p>




    
        
        
        
        
    
<img
        
        src="/posts/tutorials/p2p/ipfs-easy-use/ipfs-origin-high_hu3eea88f8be2338a28eef177f823f2105_36095_828x210_resize_q75_h2_box_3.webp"
        alt="/posts/tutorials/p2p/ipfs-easy-use/ipfs-origin-high_hu3eea88f8be2338a28eef177f823f2105_36095_828x210_resize_q75_h2_box_3.webp"
        title="IPFS 占用大量资源"
         height="210"
         width="828"
        loading="lazy"
    /></p>
<p>这个时候我们就需要调整配置文件中的参数来想办法降低资源占用，以使 IPFS 不影响我们的日常工作。其实 IPFS 已经提供了<a href="https://docs.ipfs.io/how-to/default-profile/" target="_blank" rel="noopener noreffer" class="post-link">好几个配置文件</a>，通过 <code>ipfs config profile --help</code> 可查看具体介绍。</p>
<blockquote>
<p>profile 不知道怎么翻译合适，翻译成文件不太准确，ipfs 中应用这些 profile 只是修改某些特定选项，并不是配置文件的完全改变</p>
</blockquote>
<p>我推荐在低配置的服务器和个人电脑上应用 <code>lowpower</code> 配置，<code>ipfs config profile apply lowpower</code>，这会限制 IPFS 维持的连接数量，降低网络占用，还会降低 GC 频率，这可以明显的降低 cpu 占用，我的测试可以使 cpu 占用从 80% 以上降低到 20% 以下。当然，资源占用的降低也会导致通讯效率的降低，会使内容寻址时间增长，影响使用的体验。如果你的使用方式是类似于 RSS 订阅和离线查看的模式，增长的寻址时间可以忽略不记。</p>
<p>如果你是在拥有公网 IP 的服务器上运行 IPFS，还推荐应用 <code>server</code> 配置，<code>ipfs config profile apply server</code>，这会关闭本地网络的节点发现，因为这是无意义的，这样也可以降低网络占用。</p>
<p>




    
        
        
        
        
    
<img
        
        src="/posts/tutorials/p2p/ipfs-easy-use/ipfs-now-low_hucf37f9c7b9809966f20b342d5b3216f0_47398_813x258_resize_q75_h2_box_3.webp"
        alt="/posts/tutorials/p2p/ipfs-easy-use/ipfs-now-low_hucf37f9c7b9809966f20b342d5b3216f0_47398_813x258_resize_q75_h2_box_3.webp"
        title="IPFS 优化后"
         height="258"
         width="813"
        loading="lazy"
    /></p>
<h2 id="后言"><a href="#后言" class="header-mark headerLink">后言</a></h2>
<p>20 年 11 月底，我发布了 <a href="../ipfs/" rel="" class="post-link">《IPFS 新手指北》</a> 这篇文章，期待 IPFS 能够迅猛发展，成为下一代 Web 基础设施。不知不觉已经过去一年半了，就目前情况来看 IPFS 虽然仍在不断发展，但还是在半死不活的状态，这一点让我非常失望。</p>
<p>但仔细一想，期待某门技术成为下一个主流本身就是不合理的。任何技术都应该是在广泛的需求之下才有可能成长为广泛应用的主流，而不是说你有某些好的特性就一定能够被广泛接受。从需求上讲，我们确实需要基于 P2P 的内容发布，也需要基于内容的寻址方式，这些都具有非常好的优点，但并不能满足我们对互联网的全部需求。我们在期望内容不可变、内容不被删除的同时，也会希望能够拥有删除或者修改某个内容的权利；我们喜欢 P2P 的去中心化内容分发方式，但不能否认任何人都希望延迟更低、速度更快；我们还会希望对内容具有更多控制权，包括细致的访问控制、更灵活的表达形式&hellip;&hellip;</p>
<p>基于以上想法，我不认为 IPFS 就是下一代 Web，也就是都在说的 Web3。但我不否认 IPFS 有巨大的潜力，在下一代 Web 中充当非常重要的角色，只是这个角色并不是全部。而基于 P2P 的内容分发方式早就不是什么新技术，BitTorrent 和 基于 BT 技术的 BtSync、BTFS 也都非常具有竞争力，IPFS 想要与其竞争需要更加努力，使其更加的易用和平民化。</p>
<p>我自己也已经使用 IPFS 接近两年，这两年的时间我自己的感觉是 IPFS 本身没有太大的突破性发展，而围绕其进行的各种营销和唬人活动层出不穷，文件挖矿、NFT 等等，不过这些也的确让更多人关注起 IPFS，并为 IPFS 网络贡献了大量节点和存储空间，但我总觉得怪怪的，这不是发展的长远之道啊。</p>
<p>不过看近几年互联网越发封闭，内容审查越发严格，想必 IPFS 这类分布式内容发布方式会被更多非技术人关注，期待在这个需求激增的关头，有更多优秀的应用浮现，将 IPFS 推展开来，让更多普通人能够更加方便的使用这些新技术，享受新技术带来的权利，那些我们本该拥有但被剥夺的权利。</p>
]]></description></item><item><title>谁不想要 2^64 个 IP 的代理池 ？</title><link>https://zu1k.com/posts/tutorials/http-proxy-ipv6-pool/</link><pubDate>Sat, 07 May 2022 19:21:25 +0800</pubDate><author>zu1k</author><guid>https://zu1k.com/posts/tutorials/http-proxy-ipv6-pool/</guid><description><![CDATA[<h2 id="前言"><a href="#前言" class="header-mark headerLink">前言</a></h2>
<p>昨天我舍友为了爬虫购买了昂贵的 IP 代理池，我在旁边突然萌生了一个想法，现在各大 ISP/IDC 动不动就给你分配一整个 64 位前缀的 IPv6 网段，我们能不能好好利用一下这庞大的 IPv6 IP 资源呢？</p>
<p>有了这个想法我就睡不着了，今天一大早（9点半）我就起来着手研究，最终成功实现每一个请求从一个单独的 IPv6 地址发出。</p>
<p>先看效果，我把写好的程序放在服务器上跑了一会，下面是 Cloudflare 统计的访问信息，可以看到独立访问者 (独立 IP) 数量达到了我的小博客前所未有的数量，基本上是一个请求一个独立 IP，效果非常不错。</p>
<p>




    
        
        
        
        
    
<img
        
        src="/posts/tutorials/http-proxy-ipv6-pool/cf-statistic_huf4251d5f550aa4feede29971b2c7abfb_32579_1045x343_resize_q75_h2_box_3.webp"
        alt="/posts/tutorials/http-proxy-ipv6-pool/cf-statistic_huf4251d5f550aa4feede29971b2c7abfb_32579_1045x343_resize_q75_h2_box_3.webp"
        title="Cloudflare 统计"
         height="343"
         width="1045"
        loading="lazy"
    /></p>
<h2 id="教程"><a href="#教程" class="header-mark headerLink">教程</a></h2>
<p>首先你要有一整个 IPv6 子网路由给你，当遇到吝啬的服务商，即使他们有巨多的 IPv6 资源，他也不给你用，这种情况你没辙。不过幸好，绝大多数 ISP/IDC 都会给你一整个 IPv6 <code>/64</code> 子网，有的甚至可以申请 <code>/56</code> 子网，这数量又增加了好几个数量级，所以你几乎不必担心。</p>
<p>为了方便实验，我购买了 <a href="https://www.vultr.com/?ref=9039594-8H" target="_blank" rel="noopener noreffer" class="post-link">[Vultr 的服务器]</a>，如果你还没有注册，可以使用我的 <a href="https://www.vultr.com/?ref=9039594-8H" target="_blank" rel="noopener noreffer" class="post-link">[AFF 链接]</a>.</p>
<p>你可以通过 <code>ip a</code> 命令查看网络接口的地址，从而获取你的 IPv6 子网信息：</p>
<div class="highlight"><div class="chroma">
<div class="table-wrapper"><table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ ip a
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">2: enp1s0: &lt;BROADCAST,MULTICAST,ALLMULTI,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc fq state UP group default qlen <span class="m">1000</span>
</span></span><span class="line"><span class="cl">    ......
</span></span><span class="line"><span class="cl">    inet6 2001:19f0:6001:48e4:5400:3ff:fefa:a71d/64 scope global dynamic mngtmpaddr 
</span></span><span class="line"><span class="cl">       valid_lft 2591171sec preferred_lft 603971sec
</span></span><span class="line"><span class="cl">    inet6 fe80::b155:e257:a8f7:6940/64 scope link stable-privacy 
</span></span><span class="line"><span class="cl">       valid_lft forever preferred_lft forever
</span></span></code></pre></td></tr></table></div>
</div>
</div><p>可以看到，默认给你的 IPv6 地址是动态的，这是由 SLAAC 协议根据前缀和 Mac 地址自动生成的; 还有一个 <code>fe80</code> 开头的 IPv6 地址，这也是自动分配的本地链路地址。这很好，通过这些无状态地址配置协议，使 IPv6 避免的手动配置，即插即用。</p>
<p>在我的试验中，我拿到的子网为 <code>2001:19f0:6001:48e4::/64</code>，下面都以此为基础。</p>
<p><strong>绑定和路由</strong></p>
<p>在拿到 IPv6 子网后，需要添加路由。</p>
<div class="highlight"><div class="chroma">
<div class="table-wrapper"><table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="c1"># ip addr add local 2001:19f0:6001:48e4::/64 dev lo </span>
</span></span><span class="line"><span class="cl"><span class="c1"># 纠正：无需添加地址，这一行只能添加一个地址。我们通过 ip_nonlocal_bind 来允许绑定</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">ip route add <span class="nb">local</span> 2001:19f0:6001:48e4::/64 dev enp1s0
</span></span></code></pre></td></tr></table></div>
</div>
</div><p>为了能够绑定任意 IP，我们需要开启内核的 <code>ip_nonlocal_bind</code> 特性：</p>
<div class="highlight"><div class="chroma">
<div class="table-wrapper"><table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">sysctl net.ipv6.ip_nonlocal_bind<span class="o">=</span><span class="m">1</span>
</span></span></code></pre></td></tr></table></div>
</div>
</div><p><strong>NDP</strong></p>
<p>类似于 IPv4 中 ARP 协议的作用，IPv6 中需要使用 <code>ND</code> 协议来发现邻居并确定可用路径。我们需要开启一个 <code>ND</code> 代理：</p>
<p>安装 <code>ndppd</code>: <code>apt install ndppd</code></p>
<p>编辑 <code>/etc/ndppd.conf</code> 文件:</p>
<div class="highlight"><div class="chroma">
<div class="table-wrapper"><table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">route-ttl 30000
</span></span><span class="line"><span class="cl">proxy enp1s0 {
</span></span><span class="line"><span class="cl">    router no
</span></span><span class="line"><span class="cl">    timeout 500
</span></span><span class="line"><span class="cl">    ttl 30000
</span></span><span class="line"><span class="cl">    rule 2001:19f0:6001:48e4::/64 {
</span></span><span class="line"><span class="cl">        static
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table></div>
</div>
</div><p>启动 <code>ndppd</code>: <code>systemctl start ndppd</code></p>
<div class="details admonition note open">
        <div class="details-summary admonition-title">
            <i class="icon icon-pencil"></i>注意<i class="details-icon icon-angle-circled-right"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><p>只有使用 ND 协议进行主机发现的时候才需要开启 NDP。</p>
<p>如果整个子网是直接路由过来，则无需进行这一步。例如使用 Linode 或 He.com Tunnelbroker</p>
</div>
        </div>
    </div>
<p><strong>验证</strong></p>
<p>接下来你可以验证一下了，用 <code>curl --interface</code> 指定出口 IP：</p>
<div class="highlight"><div class="chroma">
<div class="table-wrapper"><table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ curl --interface 2001:19f0:6001:48e4::1 ipv6.ip.sb
</span></span><span class="line"><span class="cl">2001:19f0:6001:48e4::1
</span></span><span class="line"><span class="cl">$ curl --interface 2001:19f0:6001:48e4::2 ipv6.ip.sb
</span></span><span class="line"><span class="cl">2001:19f0:6001:48e4::2
</span></span></code></pre></td></tr></table></div>
</div>
</div><p>可以看到，能够按照我们指定的任意 IP 进行请求</p>
<h2 id="http-代理"><a href="#http-代理" class="header-mark headerLink">Http 代理</a></h2>
<p>为了方便使用，使用 Rust 写了一个 http 代理服务端，每一个请求会走指定 IPv6 子网下随机 IP，算是一个基础 demo</p>
<div class="highlight"><div class="chroma">
<div class="table-wrapper"><table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">./http-proxy-ipv6-pool -b 127.0.0.1:51080 -i 2001:19f0:6001:48e4::/64
</span></span></code></pre></td></tr></table></div>
</div>
</div><div class="highlight"><div class="chroma">
<div class="table-wrapper"><table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ <span class="k">while</span> true<span class="p">;</span> <span class="k">do</span> curl -x http://127.0.0.1:51080 ipv6.ip.sb<span class="p">;</span> <span class="k">done</span>
</span></span><span class="line"><span class="cl">2001:19f0:6001:48e4:971e:f12c:e2e7:d92a
</span></span><span class="line"><span class="cl">2001:19f0:6001:48e4:6d1c:90fe:ee79:1123
</span></span><span class="line"><span class="cl">2001:19f0:6001:48e4:f7b9:b506:99d7:1be9
</span></span><span class="line"><span class="cl">2001:19f0:6001:48e4:a06a:393b:e82f:bffc
</span></span><span class="line"><span class="cl">2001:19f0:6001:48e4:245f:8272:2dfb:72ce
</span></span><span class="line"><span class="cl">2001:19f0:6001:48e4:df9e:422c:f804:94f7
</span></span><span class="line"><span class="cl">2001:19f0:6001:48e4:dd48:6ba2:ff76:f1af
</span></span><span class="line"><span class="cl">2001:19f0:6001:48e4:1306:4a84:570c:f829
</span></span><span class="line"><span class="cl">2001:19f0:6001:48e4:6f3:4eb:c958:ddfa
</span></span><span class="line"><span class="cl">2001:19f0:6001:48e4:aa26:3bf9:6598:9e82
</span></span><span class="line"><span class="cl">2001:19f0:6001:48e4:be6b:6a62:f8f7:a14d
</span></span><span class="line"><span class="cl">2001:19f0:6001:48e4:b598:409d:b946:17c
</span></span></code></pre></td></tr></table></div>
</div>
</div><p>欢迎 Star: <a href="https://github.com/zu1k/http-proxy-ipv6-pool" target="_blank" rel="noopener noreffer" class="post-link">https://github.com/zu1k/http-proxy-ipv6-pool</a></p>
<h2 id="碎碎念"><a href="#碎碎念" class="header-mark headerLink">碎碎念</a></h2>
<!-- ### Proxypool 项目

舍友要买代理池，我就去 GitHub 上搜了一下，没想到我之前早已停更的项目竟然排在第一位。

![GitHub 搜 proxypool](github-proxypool.png)

排名第二的是专门给爬虫准备的代理池，作者是我的师兄，他对爬虫有非常深入的研究，推荐给大家。 -->
<h3 id="一开始的想法"><a href="#一开始的想法" class="header-mark headerLink">一开始的想法</a></h3>
<p>其实我一开始的想法并不是直接给接口附加整个 IP 段的。一开始我并不知道网络接口可以直接附加一整个 IP 段，考虑到这个 IPv6 段数量过于庞大，通过枚举给接口附加多个静态 IP 显然不现实，所以我就在想办法去自己封装 IP 包然后进行注入。</p>
<p>我想到了两个注入数据包的方案：</p>
<ol>
<li>可以完全自己封装 IPv6 包以及下层协议，通过网卡的 raw fd 直接写数据</li>
</ol>
<p>这个方案在我想到的一瞬间我就放弃了，因为协议过于复杂，我根本不可能实现</p>
<ol start="2">
<li>创建一个 TUN 设备，配置这个 TUN 设备的网段为 IPv6 子网，然后将 TUN 设备和真实网络设备创建网桥。</li>
</ol>
<p>通过 TUN 向系统网络栈注入源 IP 为网段下随机的 IPv6 地址，伪造有众多 host 的假象。</p>
<p>因为前面稍微了解过 TUN (可以看我之前写的文章<a href="../../coding/tun-mode/" rel="" class="post-link">[使用 TUN 的模式]</a>)，所以自然而然我就会有这个想法，并且我深信这是可行的。我之所以认为这样可行，是因为之前搞过 <a href="../../coding/set-ipv6-for-every-docker-container/" rel="" class="post-link">[给每一个 Docker 容器一个独立的 IP]</a>，同样是充分利用丰富的 IPv6 资源，感兴趣的同学可以看一下。</p>
<p>通过搜索资料，最后确定使用 TUN 不可行，至少要用 TAP，<a href="https://serverfault.com/questions/949945/ipv6-on-Linux-tun-tap-ndp-not-working" target="_blank" rel="noopener noreffer" class="post-link">[因为要处理 NDP 协议]</a>，具体后面的细节我也没有深入研究。</p>
<p>幸亏后面搜资料发现了本文方便的方法，才避免了我陷入这些迷途。反思一下，即自己的知识不够，对 Linux 内核及其提供的众多功能了解不够深入，导致人家原本就有的功能自己根本不知道，所以想不出合适的方案。</p>
<h3 id="waf"><a href="#waf" class="header-mark headerLink">WAF</a></h3>
<p>我也不是非常了解，现在的 WAF 是不是就是单纯根据 IP 来进行限流限速 ？如果真是这样，那利用这庞大的 IPv6 资源岂不是轻松绕过封禁。</p>
<p>如果是会直接封禁或者限制整个子网，会不会有很严重的误杀，毕竟不是所有 ISP 都会这么大方的给一整个 IP 段。</p>
<p>有了解的小伙伴欢迎评论交流。</p>
]]></description></item><item><title>垃圾校园网，我忍不了了</title><link>https://zu1k.com/posts/tutorials/campus-network-speed-overlay/</link><pubDate>Sun, 11 Apr 2021 17:11:00 +0800</pubDate><author>zu1k</author><guid>https://zu1k.com/posts/tutorials/campus-network-speed-overlay/</guid><description><![CDATA[<p>记得大一刚入学时，免费的校园网是上下行对等的100Mbps带宽，虽然赶不上家里的速度，但是用起来还是比较舒服的</p>
<p>万万没想到，当别的学校都在忙着升级成千兆网络的时候，自己学校竟然来了个反向操作，30Mbps限速，真TMD鬼，不知道怎么想的</p>
<p>这垃圾校园网，我是忍不了了，考虑到每个人都能多个设备同时登录，肯定就有多拨的可能，那就搞起来！</p>
<h2 id="linux下手工操作"><a href="#linux下手工操作" class="header-mark headerLink">Linux下手工操作</a></h2>
<p>本着学习的态度，上来肯定要先在Linux下手动操作一遍（其实我是先用iKuai验证可行后，才尝试用Linux手工配的</p>
<p>我们的基本思路是：</p>
<ol>
<li>拿到多个IP</li>
<li>过了学校的联网认证</li>
<li>进行负载均衡</li>
</ol>
<p>以下所有操作都需要root权限</p>
<h3 id="利用macvlan获取多个ip"><a href="#利用macvlan获取多个ip" class="header-mark headerLink">利用macvlan获取多个IP</a></h3>
<p>首先要创建多个虚拟网络接口，利用不同的Mac地址进行DHCP获取多个不同的IP地址</p>
<p>在Linux下，内核提供的macvlan就可以实现我们的需求，从Linux Kernel 3.9开始就支持了貌似，所以只要不是安装非常老的系统都是支持的</p>
<p>查看一下你的系统是否支持：</p>
<div class="highlight"><div class="chroma">
<div class="table-wrapper"><table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># modprobe macvlan</span>
</span></span><span class="line"><span class="cl"><span class="c1"># lsmod | grep macvlan</span>
</span></span><span class="line"><span class="cl">macvlan                <span class="m">24576</span>  <span class="m">0</span>
</span></span></code></pre></td></tr></table></div>
</div>
</div><p>如果显示类似上面的内容就表示支持</p>
<p>添加一个macvlan类型的网络接口：</p>
<div class="highlight"><div class="chroma">
<div class="table-wrapper"><table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">ip link add link &lt;physical-network-interface-name&gt; &lt;new-network-interface-name&gt; <span class="nb">type</span> macvlan
</span></span></code></pre></td></tr></table></div>
</div>
</div><p>例如，通过 <code>ip addr</code> 或者 <code>ifconfig</code> 查看到物理网卡名为 <code>eth0</code>，新网络接口名我们用 <code>vmac0</code> <code>vmac1</code> 这样的表示，命令如下：</p>
<div class="highlight"><div class="chroma">
<div class="table-wrapper"><table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">ip link add link eth0 vmac0 <span class="nb">type</span> macvlan
</span></span><span class="line"><span class="cl">ip link add link eth0 vmac1 <span class="nb">type</span> macvlan
</span></span></code></pre></td></tr></table></div>
</div>
</div><p>这样就创建了两个新的网络接口，依附于物理接口 <code>eth0</code>，两个新网络接口的mac地址是自动分配的，每一次新建都会随机生成。</p>
<p>如果想要手动指定mac地址，可以使用下面的命令:</p>
<div class="highlight"><div class="chroma">
<div class="table-wrapper"><table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">ip link add link &lt;physical-network-interface-name&gt; &lt;new-network-interface-name&gt; address &lt;mac-address&gt; <span class="nb">type</span> macvlan
</span></span><span class="line"><span class="cl">例如：
</span></span><span class="line"><span class="cl">ip link add link eth0 vmac0 address 11:22:33:44:55:66 <span class="nb">type</span> macvlan
</span></span></code></pre></td></tr></table></div>
</div>
</div><div class="details admonition tip open">
        <div class="details-summary admonition-title">
            <i class="icon icon-lightbulb"></i>技巧<i class="details-icon icon-angle-circled-right"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">更加详细的命令通过 <code>ip link help</code> 和 <code>man ip link</code> 查看</div>
        </div>
    </div>
<p>经过上面这一步，就就可以通过 <code>ip link</code> 看到多了两个网络接口</p>
<div class="highlight"><div class="chroma">
<div class="table-wrapper"><table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">4: vmac0@eth0: &lt;BROADCAST,MULTICAST&gt; mtu <span class="m">1500</span> qdisc noop state DOWN group default qlen <span class="m">1000</span>
</span></span><span class="line"><span class="cl">    link/ether 5a:5d:f9:1e:b8:19 brd ff:ff:ff:ff:ff:ff
</span></span><span class="line"><span class="cl">5: vmac1@eth0: &lt;BROADCAST,MULTICAST&gt; mtu <span class="m">1500</span> qdisc noop state DOWN group default qlen <span class="m">1000</span>
</span></span><span class="line"><span class="cl">    link/ether 66:50:b5:23:d8:ce brd ff:ff:ff:ff:ff:ff
</span></span></code></pre></td></tr></table></div>
</div>
</div><p>然后需要获取到多个IP，直接执行 <code>dhclient</code> 即可</p>
<h3 id="进行联网认证"><a href="#进行联网认证" class="header-mark headerLink">进行联网认证</a></h3>
<p>我们学校用的是深澜的认证系统，对其认证流程分析后，写了一个小工具:<a href="/posts/tutorials/campus-network-speed-overlay/sdu-srun.zip" rel="" class="post-link">多账号登录认证工具</a></p>
<div class="details admonition info open">
        <div class="details-summary admonition-title">
            <i class="icon icon-info-circled"></i>信息<i class="details-icon icon-angle-circled-right"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><p>2021年11月4日 更新</p>
<p>用Rust写了一个新的登录工具，更轻量更好用</p>
<p><a href="https://github.com/zu1k/sdusrun" target="_blank" rel="noopener noreffer" class="post-link">https://github.com/zu1k/sdusrun</a></p>
</div>
        </div>
    </div>
<p>在启动前先修改配置文件，username为学号，password为上网认证的密码，ip分别写刚刚 macvlan 获取到的IP</p>
<p>学校限制的每个人最多5台设备同时在线，新登录的设备会把前面的设备顶下去，所以最好联合舍友用多个人的账号进行认证</p>
<div class="highlight"><div class="chroma">
<div class="table-wrapper"><table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">login</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span>- <span class="nt">username</span><span class="p">:</span><span class="w"> </span><span class="l">201XXXXX1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="nt">password</span><span class="p">:</span><span class="w"> </span><span class="l">user1-password</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="nt">ip</span><span class="p">:</span><span class="w"> </span><span class="m">10.0.0.1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span>- <span class="nt">username</span><span class="p">:</span><span class="w"> </span><span class="l">201XXXXX1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="nt">password</span><span class="p">:</span><span class="w"> </span><span class="l">user1-password</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="nt">ip</span><span class="p">:</span><span class="w"> </span><span class="m">10.0.0.2</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span>- <span class="nt">username</span><span class="p">:</span><span class="w"> </span><span class="l">201XXXXX2</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="nt">password</span><span class="p">:</span><span class="w"> </span><span class="l">user2-password</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="nt">ip</span><span class="p">:</span><span class="w"> </span><span class="m">10.0.0.3</span><span class="w">
</span></span></span></code></pre></td></tr></table></div>
</div>
</div><div class="details admonition note open">
        <div class="details-summary admonition-title">
            <i class="icon icon-pencil"></i>注意<i class="details-icon icon-angle-circled-right"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">认证成功后即可进行下面的步骤，如果认证失败需要检查账号密码是否正确，本工具也不能保证后续系统更新后仍能使用，必要时可登录认证后台手工添加mac认证白名单</div>
        </div>
    </div>
<h3 id="进行路由级别的分流"><a href="#进行路由级别的分流" class="header-mark headerLink">进行路由级别的分流</a></h3>
<p>经过上面的步骤，其实现在已经有多个可以上网的接口了，每一个接口都限速30Mbps，可以通过修改路由表验证，但是测速发现还是总速度还是30Mbps，速度并没有叠加</p>
<p>这其实是因为你的主机只有一个默认网关，流量实际上只走了一条线，所以还是受单接口限速的限制。我们的目的是让流量能够分别走多个接口，从而达到速度叠加的效果，也就是常说的负载均衡</p>
<p>思路是：通过iptables规则给数据包打上标记，然后通过策略路由根据标记来选择走哪个接口出去。需要注意不同包之间的关系，追踪连接状态并恢复标记，否则的话同一个连接的不同包走了不同的接口，会被丢弃掉。</p>
<h4 id="创建路由表"><a href="#创建路由表" class="header-mark headerLink">创建路由表</a></h4>
<p>首先创建多个路由表，因为每一个路由表只能默认走一个接口，所以刚刚创建了多少虚拟网络接口，这里就要增加几个路由表，我按照2个接口来演示</p>
<p>编辑 <code>/etc/iproute2/rt_tables</code> 文件，在文件末尾增加两个路由表</p>
<div class="highlight"><div class="chroma">
<div class="table-wrapper"><table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># 新增的路由表</span>
</span></span><span class="line"><span class="cl"><span class="m">100</span>      vmac0
</span></span><span class="line"><span class="cl"><span class="m">101</span>      vmac1
</span></span></code></pre></td></tr></table></div>
</div>
</div><p>保证新路由表中没有条目，先清空一下</p>
<div class="highlight"><div class="chroma">
<div class="table-wrapper"><table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">ip route flush table vmac0
</span></span><span class="line"><span class="cl">ip route flush table vmac1
</span></span></code></pre></td></tr></table></div>
</div>
</div><p>分别为两个路由表增加默认路由项，分别走不同的网络接口</p>
<div class="highlight"><div class="chroma">
<div class="table-wrapper"><table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">ip route add 0/0 dev vmac0 table vmac0
</span></span><span class="line"><span class="cl">ip route add 0/0 dev vmac1 table vmac1
</span></span></code></pre></td></tr></table></div>
</div>
</div><h4 id="配置iptables"><a href="#配置iptables" class="header-mark headerLink">配置iptables</a></h4>
<p>分别创建多个新的链</p>
<div class="highlight"><div class="chroma">
<div class="table-wrapper"><table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">iptables -t mangle -N VMAC0
</span></span><span class="line"><span class="cl">iptables -t mangle -A VMAC0 -j MARK --set-mark 0x100
</span></span><span class="line"><span class="cl">iptables -t mangle -A VMAC0 -j CONNMARK --save-mark
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">iptables -t mangle -N VMAC1
</span></span><span class="line"><span class="cl">iptables -t mangle -A VMAC1 -j MARK --set-mark 0x101
</span></span><span class="line"><span class="cl">iptables -t mangle -A VMAC1 -j CONNMARK --save-mark
</span></span></code></pre></td></tr></table></div>
</div>
</div><p>配置打标记的规则，每两个包（只看新建的连接）中第一个交给<code>VMAC0</code>处理，第二个交给<code>VMAC1</code>处理</p>
<div class="highlight"><div class="chroma">
<div class="table-wrapper"><table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">iptables -t mangle -A OUTPUT -o vmac+ -m state --state NEW -m statistic --mode nth --every <span class="m">2</span> --packet <span class="m">0</span> -j VMAC0
</span></span><span class="line"><span class="cl">iptables -t mangle -A OUTPUT -o vmac+ -m state --state NEW -m statistic --mode nth --every <span class="m">2</span> --packet <span class="m">1</span> -j VMAC1
</span></span><span class="line"><span class="cl">iptables -t mangle -A OUTPUT -o vmac+ -m state --state ESTABLISHED,RELATED -j CONNMARK --restore-mark
</span></span></code></pre></td></tr></table></div>
</div>
</div><h4 id="配置策略路由"><a href="#配置策略路由" class="header-mark headerLink">配置策略路由</a></h4>
<p>下面需要配置策略路由，根据我们设置的策略，流量分别由多个路由表进行路由，所以就可以走多个网络接口了</p>
<p>我们让防火墙标记为<code>0x100</code>的用<code>vmac0</code>路由表，标记为<code>0x101</code>流量的用<code>vmac1</code>路由表</p>
<div class="highlight"><div class="chroma">
<div class="table-wrapper"><table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">ip rule add fwmark 0x100 table vmac0
</span></span><span class="line"><span class="cl">ip rule add fwmark 0x101 table vmac1
</span></span></code></pre></td></tr></table></div>
</div>
</div><p>此时会出现一个问题，就是从外部发起的连接在进来后并没有打上防火墙标记，所以返回的包只能走默认的路由表。假如我们的默认路由表的默认路由是走<code>vmac0</code>，那来自<code>vmac1</code>的请求的响应包也会走<code>vmac0</code>出去，因为不属于同一个连接，这个包就会被丢掉。</p>
<p>我们的解决方法是再增加两条规则，来自哪个网卡的包的响应就从该网卡出</p>
<div class="highlight"><div class="chroma">
<div class="table-wrapper"><table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">ip rule add from &lt;vmac0-ip&gt; table vmac0
</span></span><span class="line"><span class="cl">ip rule add from &lt;vmac1-ip&gt; table vmac1
</span></span></code></pre></td></tr></table></div>
</div>
</div><h4 id="用作路由器"><a href="#用作路由器" class="header-mark headerLink">用作路由器</a></h4>
<p>如果这台Linux需要用作网关，需要配置PREROUTING链，这里假设内网网段为 <code>192.168/16</code></p>
<div class="highlight"><div class="chroma">
<div class="table-wrapper"><table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">iptables -t mangle -A PREROUTING -s 192.168/16 ! -d 192.168/16 -m state --state NEW -m statistic --mode nth --every <span class="m">2</span> --packet <span class="m">0</span> -j VMAC0
</span></span><span class="line"><span class="cl">iptables -t mangle -A PREROUTING -s 192.168/16 ! -d 192.168/16 -m state --state NEW -m statistic --mode nth --every <span class="m">2</span> --packet <span class="m">1</span> -j VMAC1
</span></span><span class="line"><span class="cl">iptables -t mangle -A PREROUTING -s 192.168/16 ! -d 192.168/16 -m state --state ESTABLISHED,RELATED -j CONNMARK --restore-mark
</span></span></code></pre></td></tr></table></div>
</div>
</div><p>同时需要对内网流量进行SNAT</p>
<div class="highlight"><div class="chroma">
<div class="table-wrapper"><table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">iptables -t nat -A POSTROUTING -o vmac+ -j MASQUERADE
</span></span></code></pre></td></tr></table></div>
</div>
</div><p>经过上面的步骤，已经能够利用多个网络接口了。不过我们本质上是通过连接分流的，同一个连接的所有包会走同一个接口出去，所以如果你的程序是单线程网络，就看不到加速效果。可以通过speedtest多线程来进行测试，可以看到明显的网速叠加。</p>
<div class="details admonition note open">
        <div class="details-summary admonition-title">
            <i class="icon icon-pencil"></i>注意<i class="details-icon icon-angle-circled-right"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><p>我刚刚的演示重启后虚拟网卡会丢失，因为自动分配的mac地址，重新运行命令会导致mac和ip变动，需要重新认证</p>
<p>可以使用指定mac地址的方法创建，也有持久化虚拟网卡的方法，可以一劳永逸</p>
<p>后面会将更加成熟的方法，这里手工配置不是重点，需要的自行学习研究吧！</p>
</div>
        </div>
    </div>
<h2 id="使用openwrtmwan3"><a href="#使用openwrtmwan3" class="header-mark headerLink">使用OpenWrt+mwan3</a></h2>
<p>我比较推荐在宿舍里搞个软路由，普通的路由刷OpenWrt或者弄个树莓派刷OpenWrt都行，可以考虑买个二手矿渣 <code>newifi 3</code> 或者 <code>R2S</code></p>
<p>因为在OpenWrt里面有现成的插件，可以非常方便的创建多个虚拟网络接口，并能够利用图形界面配置更加强大的分流策略。</p>
<p>主要涉及到两个插件：kmod-macvlan和mwan3</p>
<h3 id="添加设备获取ip"><a href="#添加设备获取ip" class="header-mark headerLink">添加设备，获取IP</a></h3>
<p>首先在正确配置好网络的基础上，先创建网络设备，类型是macvlan，在学习了Linux下手工操作的基础上，这里的配置项都好理解</p>
<p>




    
        
        
        
        
    
<img
        
        src="/posts/tutorials/campus-network-speed-overlay/openwrt/network-device_hua4a41f9c73827df582ea964037e09721_41569_656x368_resize_q75_h2_box_3.webp"
        alt="/posts/tutorials/campus-network-speed-overlay/openwrt/network-device_hua4a41f9c73827df582ea964037e09721_41569_656x368_resize_q75_h2_box_3.webp"
        title="网络设备"
         height="368"
         width="656"
        loading="lazy"
    /></p>
<p>要几拨就添加几个设备，注意最好手工指定一下mac，基础设备选正常上网的wan口物理设备</p>
<p>




    
        
        
        
        
    
<img
        
        src="/posts/tutorials/campus-network-speed-overlay/openwrt/network-device-add_hu4a2aa46d6abc4695e42f682157e0b152_20526_561x321_resize_q75_h2_box_3.webp"
        alt="/posts/tutorials/campus-network-speed-overlay/openwrt/network-device-add_hu4a2aa46d6abc4695e42f682157e0b152_20526_561x321_resize_q75_h2_box_3.webp"
        title="添加网络设备"
         height="321"
         width="561"
        loading="lazy"
    /></p>
<p>然后添加相同数量的接口，协议选DHCP，接口设备选刚刚创建的，一一对应</p>
<p>




    
        
        
        
        
    
<img
        
        src="/posts/tutorials/campus-network-speed-overlay/openwrt/network-interface-add_hu621dfbbca86664cd67b870fcdae67db3_36472_567x366_resize_q75_h2_box_3.webp"
        alt="/posts/tutorials/campus-network-speed-overlay/openwrt/network-interface-add_hu621dfbbca86664cd67b870fcdae67db3_36472_567x366_resize_q75_h2_box_3.webp"
        title="添加网络接口"
         height="366"
         width="567"
        loading="lazy"
    /></p>
<p>接口添加好后，进行连接就会自动获取IP了，然后与上面手工方式一样，把所有IP都认证一下</p>
<h3 id="配置mwan3分流"><a href="#配置mwan3分流" class="header-mark headerLink">配置mwan3分流</a></h3>
<p>在mwan的管理界面，首先添加接口，与网络里面刚刚配置的接口一一对应</p>
<p>




    
        
        
        
        
    
<img
        
        src="/posts/tutorials/campus-network-speed-overlay/openwrt/mwan-interface_hu4152b2e4189d37b51917b8dfa8415502_33920_797x426_resize_q75_h2_box_3.webp"
        alt="/posts/tutorials/campus-network-speed-overlay/openwrt/mwan-interface_hu4152b2e4189d37b51917b8dfa8415502_33920_797x426_resize_q75_h2_box_3.webp"
        title="添加接口"
         height="426"
         width="797"
        loading="lazy"
    /></p>
<div class="details admonition note open">
        <div class="details-summary admonition-title">
            <i class="icon icon-pencil"></i>注意<i class="details-icon icon-angle-circled-right"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">这里涉及到接口可用性的检测，需要仔细设置一下，后面的分流需要依赖这个可用性检测，总不能把流量分给不可用的接口吧</div>
        </div>
    </div>
<p>然后添加成员，与刚刚添加的接口一一对应，这里添加的可以在后面策略那里选择</p>
<p>




    
        
        
        
        
    
<img
        
        src="/posts/tutorials/campus-network-speed-overlay/openwrt/mwan-member_hu128229219abfac83ba956b2bc1ee0e26_32285_730x372_resize_q75_h2_box_3.webp"
        alt="/posts/tutorials/campus-network-speed-overlay/openwrt/mwan-member_hu128229219abfac83ba956b2bc1ee0e26_32285_730x372_resize_q75_h2_box_3.webp"
        title="添加成员"
         height="372"
         width="730"
        loading="lazy"
    /></p>
<p>添加策略，图中第一条是负载均衡策略，刚刚添加的成员全都选中，意思就是说同时使用这所有的网络</p>
<p>后面几条策略分别是用来测试想用网络设备的</p>
<p>




    
        
        
        
        
    
<img
        
        src="/posts/tutorials/campus-network-speed-overlay/openwrt/mwan-policy_huf0057ef3cab073b3a770a321c785247d_54579_766x533_resize_q75_h2_box_3.webp"
        alt="/posts/tutorials/campus-network-speed-overlay/openwrt/mwan-policy_huf0057ef3cab073b3a770a321c785247d_54579_766x533_resize_q75_h2_box_3.webp"
        title="添加策略"
         height="533"
         width="766"
        loading="lazy"
    /></p>
<p>最后添加分流规则，最简单的如图所示，目的地址不限，端口不限，协议不限，都走负载均衡策略，也就是从所有网口出</p>
<p>




    
        
        
        
        
    
<img
        
        src="/posts/tutorials/campus-network-speed-overlay/openwrt/mwan-rule_hua52f95ea462474b0cf9ac8cb58272a1d_39444_666x444_resize_q75_h2_box_3.webp"
        alt="/posts/tutorials/campus-network-speed-overlay/openwrt/mwan-rule_hua52f95ea462474b0cf9ac8cb58272a1d_39444_666x444_resize_q75_h2_box_3.webp"
        title="添加规则"
         height="444"
         width="666"
        loading="lazy"
    /></p>
<p>




    
        
        
        
        
    
<img
        
        src="/posts/tutorials/campus-network-speed-overlay/openwrt/mwan-rule-config_hu5f3f57b70c1748ba92fc557370ed1263_30177_626x380_resize_q75_h2_box_3.webp"
        alt="/posts/tutorials/campus-network-speed-overlay/openwrt/mwan-rule-config_hu5f3f57b70c1748ba92fc557370ed1263_30177_626x380_resize_q75_h2_box_3.webp"
        title="规则配置"
         height="380"
         width="626"
        loading="lazy"
    /></p>
<p>在状态面板可以看到，多拨成功</p>
<p>




    
        
        
        
        
    
<img
        
        src="/posts/tutorials/campus-network-speed-overlay/openwrt/status_hu8611a9ab490101676948cbbd5cc19e0d_17650_793x220_resize_q75_h2_box_3.webp"
        alt="/posts/tutorials/campus-network-speed-overlay/openwrt/status_hu8611a9ab490101676948cbbd5cc19e0d_17650_793x220_resize_q75_h2_box_3.webp"
        title="多拨成功"
         height="220"
         width="793"
        loading="lazy"
    /></p>
<div class="details admonition tip open">
        <div class="details-summary admonition-title">
            <i class="icon icon-lightbulb"></i>技巧<i class="details-icon icon-angle-circled-right"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">mwan3代码在：<a href="https://github.com/openwrt/packages/tree/master/net/mwan3" target="_blank" rel="noopener noreffer" class="post-link">https://github.com/openwrt/packages/tree/master/net/mwan3</a></div>
        </div>
    </div>
<h2 id="爱快分流很强大"><a href="#爱快分流很强大" class="header-mark headerLink">爱快，分流很强大</a></h2>
<p>正好我在的实验室里有老旧的台式机，又有多个网卡，我就安装了以分流著称的iKuai系统</p>
<p>爱快路由系统对性能要求很高，64位甚至要求4G运存才能安装，不太建议宿舍用，不过实话实话这个是真的爽</p>
<p>首先在网路设置中，选择正确的物理网卡，接入方式选<code>基于物理网卡的混合模式</code>，在DHCP模式下添加多个虚拟网络接口，mac地址自己指定</p>
<p>




    
        
        
        
        
    
<img
        
        src="/posts/tutorials/campus-network-speed-overlay/ikuai/add-wan-if_hu684daeba6b87130d2284bdfe353c3f23_139130_719x426_resize_q75_h2_box_3.webp"
        alt="/posts/tutorials/campus-network-speed-overlay/ikuai/add-wan-if_hu684daeba6b87130d2284bdfe353c3f23_139130_719x426_resize_q75_h2_box_3.webp"
        title="添加网络接口"
         height="426"
         width="719"
        loading="lazy"
    /></p>
<p>关开网络接口，让其DHCP获取到IP地址，然后按照之前说的方法进行网络认证</p>
<p>然后进入分流设置，配置多线负载</p>
<p>




    
        
        
        
        
    
<img
        
        src="/posts/tutorials/campus-network-speed-overlay/ikuai/load-balance_huee21e4efc6f414d5c51608629c69f835_46739_599x128_resize_q75_h2_box_3.webp"
        alt="/posts/tutorials/campus-network-speed-overlay/ikuai/load-balance_huee21e4efc6f414d5c51608629c69f835_46739_599x128_resize_q75_h2_box_3.webp"
        title="负载均衡"
         height="128"
         width="599"
        loading="lazy"
    /></p>
<p>添加的时候有多种负载模式可供选择，可以添加多个负载规则。注意要把前面创建的网络接口全部开启</p>
<p>




    
        
        
        
        
    
<img
        
        src="/posts/tutorials/campus-network-speed-overlay/ikuai/add-load-balance_hu0871626870399a0d506d030ec9889f3e_19308_664x344_resize_q75_h2_box_3.webp"
        alt="/posts/tutorials/campus-network-speed-overlay/ikuai/add-load-balance_hu0871626870399a0d506d030ec9889f3e_19308_664x344_resize_q75_h2_box_3.webp"
        title="负载均衡"
         height="344"
         width="664"
        loading="lazy"
    /></p>
<p>对！就是这么简单，iKuai就是牛，已经把网速叠加成功了</p>
<h2 id="新发现"><a href="#新发现" class="header-mark headerLink">新发现</a></h2>
<p>在与同学的交流中，发现校园网还可以用任意手机号验证码登录，登陆后的权限是访客，不过与学生权限一样，如此看来可以利用多个手机号突破5台设备的限制了</p>
<p>注意，登录成功后一定要修改密码，否则第二次登录的时候会提示创建新账号失败，是后台的BUG，日</p>
<p>最后，向大家推荐一个讲iptables的视频，可以在Youtube或者Bilibili搜索<code>坏人的iptables小讲堂</code>，讲的真的很不错</p>
]]></description></item><item><title>IPFS 新手指北</title><link>https://zu1k.com/posts/tutorials/p2p/ipfs/</link><pubDate>Sun, 29 Nov 2020 22:21:44 +0800</pubDate><author>zu1k</author><guid>https://zu1k.com/posts/tutorials/p2p/ipfs/</guid><description><![CDATA[<h2 id="ipfs简介"><a href="#ipfs简介" class="header-mark headerLink">IPFS简介</a></h2>
<p><strong>IPFS</strong>全称<code>InterPlanetary File System</code>，中文名叫<strong>星际文件系统</strong>，听起来非常酷炫。</p>
<p>它是是一个旨在创建<strong>持久</strong>且<strong>分布式</strong>存储和<strong>共享</strong>文件的网络传输协议，是一种内容可寻址的对等超媒体分发协议。在IPFS网络中的<strong>全球所有</strong>节点将构成<strong>一个</strong>分布式文件系统，全球中的每一个人都可以通过IPFS网关存储和访问IPFS里面的文件。</p>
<p>这个酷炫的项目最初由Juan Benet设计，自2014年开始由Protocol Labs在开源社区的帮助下发展，是一个<strong>完全开源</strong>的项目。</p>
<ul>
<li><a href="https://ipfs.io/" target="_blank" rel="noopener noreffer" class="post-link">IPFS官网</a></li>
<li><a href="https://github.com/ipfs" target="_blank" rel="noopener noreffer" class="post-link">GitHub</a></li>
</ul>
<h2 id="ipfs的优点"><a href="#ipfs的优点" class="header-mark headerLink">IPFS的优点</a></h2>
<h3 id="与现有web比较"><a href="#与现有web比较" class="header-mark headerLink">与现有Web比较</a></h3>
<p>




    
<img
        
        src="compare/ipfs-illustration-http.svg"
        alt="compare/ipfs-illustration-http.svg"
        title="Today&amp;rsquo;s web is inefficient and expensive"
        
        
        loading="lazy"
    /></p>
<h4 id="现有的网络技术效率低下成本高昂"><a href="#现有的网络技术效率低下成本高昂" class="header-mark headerLink">现有的网络技术效率低下、成本高昂</a></h4>
<p>HTTP一次从一台计算机下载文件，而不是同时从多台计算机获取文件。点对点IPFS<strong>节省了大量的带宽</strong>，视频高达60%，这使得无需重复地高效地分发大量数据成为可能。</p>
<p>




    
<img
        
        src="compare/ipfs-illustration-history.svg"
        alt="compare/ipfs-illustration-history.svg"
        title="Today&amp;rsquo;s web can&amp;rsquo;t preserve humanity&amp;rsquo;s history"
        
        
        loading="lazy"
    /></p>
<h4 id="现有的网络无法保存人类的历史"><a href="#现有的网络无法保存人类的历史" class="header-mark headerLink">现有的网络无法保存人类的历史</a></h4>
<p>一个网页的平均寿命是100天，然后就永远消失了。我们这个时代的主要媒介还不够脆弱。IPFS<strong>保留文件的每一个版本</strong>，并使为镜像数据建立弹性网络变得简单。</p>
<p>




    
<img
        
        src="compare/ipfs-illustration-centralized.svg"
        alt="compare/ipfs-illustration-centralized.svg"
        title="Today&amp;rsquo;s web is centralized, limiting opportunity"
        
        
        loading="lazy"
    /></p>
<h4 id="现有的网络是集中的限制了机会"><a href="#现有的网络是集中的限制了机会" class="header-mark headerLink">现有的网络是集中的，限制了机会</a></h4>
<p>互联网作为人类历史上最伟大的均衡器之一，推动了创新的发展，但日益巩固的集权控制威胁着这一进步。IPFS通过分布式技术来避免这一点。</p>
<p>




    
<img
        
        src="compare/ipfs-illustration-network.svg"
        alt="compare/ipfs-illustration-network.svg"
        title="Today&amp;rsquo;s web is addicted to the backbone"
        
        
        loading="lazy"
    /></p>
<h4 id="现有的网络深度依赖主干网"><a href="#现有的网络深度依赖主干网" class="header-mark headerLink">现有的网络深度依赖主干网</a></h4>
<p>IPFS支持创建多样化的弹性网络，以实现<strong>持久可用性</strong>，无论是否有Internet主干网连接。这意味着发展中国家在自然灾害期间，或者在咖啡厅的wi-fi上时，能够更好地连接。</p>
<h3 id="ipfs做的更好"><a href="#ipfs做的更好" class="header-mark headerLink">IPFS做的更好</a></h3>
<p>IPFS宣称，无论你现在在用已有的Web技术干什么，IPFS都可以做到更好。</p>
<p>




    
        
        
        
        
    
<img
        
        src="/posts/tutorials/p2p/ipfs/usefull/usefull_1_hu44cd894b481e49439e4024ed796a7bf4_20225_538x166_resize_q75_h2_box_3.webp"
        alt="/posts/tutorials/p2p/ipfs/usefull/usefull_1_hu44cd894b481e49439e4024ed796a7bf4_20225_538x166_resize_q75_h2_box_3.webp"
        title="usefull 1"
         height="166"
         width="538"
        loading="lazy"
    /></p>
<ul>
<li>
<p>对于<strong>归档人员</strong></p>
<p>IPFS提供了数据块去重、高性能和基于集群的数据持久化，这有利于存储世界上的信息来造福后代</p>
</li>
<li>
<p>对于<strong>服务提供商</strong></p>
<p>IPFS提供安全的P2P内容交付，可以为服务提供者节省数百万带宽成本</p>
</li>
<li>
<p>对于<strong>研究者</strong></p>
<p>如果您使用或分发大型数据集，IPFS可以帮助您提供快速的性能和分散的归档</p>
</li>
</ul>
<p>




    
        
        
        
        
    
<img
        
        src="/posts/tutorials/p2p/ipfs/usefull/usefull_2_hud188cfbd7834764fa61fe071c6cf27c8_19823_524x160_resize_q75_h2_box_3.webp"
        alt="/posts/tutorials/p2p/ipfs/usefull/usefull_2_hud188cfbd7834764fa61fe071c6cf27c8_19823_524x160_resize_q75_h2_box_3.webp"
        title="usefull 2"
         height="160"
         width="524"
        loading="lazy"
    /></p>
<ul>
<li>
<p>对于<strong>世界发展</strong></p>
<p>对于那些互联网基础设施较差的人来说，高延迟网络是一大障碍。IPFS提供对数据的弹性访问，独立于延迟或主干网连接</p>
</li>
<li>
<p>对于<strong>区块链</strong></p>
<p>使用IPFS，您可以处理大量数据，并在事务中放置不可变的永久链接—时间戳和保护内容，而不必将数据本身放在链上</p>
</li>
<li>
<p>对于<strong>内容创造者</strong></p>
<p>IPFS充分体现了网络的自由和独立精神，可以帮助您以更低的成本交付内容</p>
</li>
</ul>
<h2 id="工作原理"><a href="#工作原理" class="header-mark headerLink">工作原理</a></h2>
<p>让我们通过向IPFS添加一个文件这个过程，来简单看一下IPFS是如何工作的</p>
<p>




    
        
        
        
        
    
<img
        
        src="/posts/tutorials/p2p/ipfs/work/work_1_huec82a8acf873cbbdd65180e0cc3cbe80_18454_715x143_resize_q75_h2_box_3.webp"
        alt="/posts/tutorials/p2p/ipfs/work/work_1_huec82a8acf873cbbdd65180e0cc3cbe80_18454_715x143_resize_q75_h2_box_3.webp"
        title="第一步"
         height="143"
         width="715"
        loading="lazy"
    /></p>
<p>IPFS将文件切割为多个小块，每个块的大小为256KB，块的数量由文件的大小决定。然后计算每个块的Hash，作为这个块的指纹。</p>
<p>




    
        
        
        
        
    
<img
        
        src="/posts/tutorials/p2p/ipfs/work/work_2_hud94bb78b709f95278d72421a0a468b77_6001_687x148_resize_q75_h2_box_3.webp"
        alt="/posts/tutorials/p2p/ipfs/work/work_2_hud94bb78b709f95278d72421a0a468b77_6001_687x148_resize_q75_h2_box_3.webp"
        title="第二步"
         height="148"
         width="687"
        loading="lazy"
    /></p>
<p>因为很多文件数据有重复的部分，在切割成小块后，这些小块有的会完全相同，表现出来就是指纹Hash相同。拥有相同指纹Hash的块被视为同一个块，所以相同的数据在IPFS都表现为同一块，这也就消除了存储相同数据的额外开销。</p>
<p>




    
        
        
        
        
    
<img
        
        src="/posts/tutorials/p2p/ipfs/work/work_3_hu5cef949eb7c1c8c22a04f4a9246efd20_12989_713x144_resize_q75_h2_box_3.webp"
        alt="/posts/tutorials/p2p/ipfs/work/work_3_hu5cef949eb7c1c8c22a04f4a9246efd20_12989_713x144_resize_q75_h2_box_3.webp"
        title="第三步"
         height="144"
         width="713"
        loading="lazy"
    /></p>
<p>IPFS网络中的每一个节点只存储自己<strong>感兴趣</strong>的内容，也就是该IPFS节点的使用者经常访问、或指定要固定的内容。</p>
<p>除此之外还需要额外存储一些索引信息，这些索引信息用来帮助文件查找的寻址工作。当我们需要获取某个块的时候，索引信息就可以告诉IPFS这个特定块在哪些节点上有存储。</p>
<p>




    
        
        
        
        
    
<img
        
        src="/posts/tutorials/p2p/ipfs/work/work_4_hu094a3b5b5c985399ecfefd792883cc42_15836_701x144_resize_q75_h2_box_3.webp"
        alt="/posts/tutorials/p2p/ipfs/work/work_4_hu094a3b5b5c985399ecfefd792883cc42_15836_701x144_resize_q75_h2_box_3.webp"
        title="第四步"
         height="144"
         width="701"
        loading="lazy"
    /></p>
<p>当我们要从IPFS中查看或者下载某个文件时，IPFS便要通过改文件的<strong>指纹Hash</strong>查询索引信息，并向自己连接的节点进行询问。这一步需要找到IPFS网络中的哪些节点存储着自己想要的文件数据块。</p>
<p>




    
        
        
        
        
    
<img
        
        src="/posts/tutorials/p2p/ipfs/work/one-ipfs-node-only_hu134fbf3dc9c72655ec002a1361ebd0db_348906_1673x1045_resize_q75_h2_box_3.webp"
        alt="/posts/tutorials/p2p/ipfs/work/one-ipfs-node-only_hu134fbf3dc9c72655ec002a1361ebd0db_348906_1673x1045_resize_q75_h2_box_3.webp"
        title="IPFS寻址"
         height="1045"
         width="1673"
        loading="lazy"
    /></p>
<p>




    
        
        
        
        
    
<img
        
        src="/posts/tutorials/p2p/ipfs/work/work_5_hu3ebe2645eb4e300f35ec45f1a3b47252_19622_710x139_resize_q75_h2_box_3.webp"
        alt="/posts/tutorials/p2p/ipfs/work/work_5_hu3ebe2645eb4e300f35ec45f1a3b47252_19622_710x139_resize_q75_h2_box_3.webp"
        title="第五步"
         height="139"
         width="710"
        loading="lazy"
    /></p>
<p>如果你无法记住IPFS中存储的文件的指纹Hash(是一段非常长的字符串)，实际上你也无须记住这个Hash，IPFS提供了<strong>IPNS</strong>来提供<strong>人类可读名字</strong>到<strong>指纹Hash</strong>之间的映射，你只需要记住你添加在IPNS中的人类可读名字即可。</p>
<h2 id="基本使用"><a href="#基本使用" class="header-mark headerLink">基本使用</a></h2>
<h3 id="安装"><a href="#安装" class="header-mark headerLink">安装</a></h3>
<p>设置环境变量<code>IPFS_PATH</code>，这个目录在后面进行初始化和使用的时候会作为IPFS的本地仓库。如果这里不进行设置，IPFS默认会使用用户目录下的<code>.ipfs</code>文件夹作为本地仓库。</p>
<p>




    
        
        
        
        
    
<img
        
        src="/posts/tutorials/p2p/ipfs/tutorial/ipfs_env_hu53d55428ab457539b5df30a7ebf7cf23_15025_610x264_resize_q75_h2_box_3.webp"
        alt="/posts/tutorials/p2p/ipfs/tutorial/ipfs_env_hu53d55428ab457539b5df30a7ebf7cf23_15025_610x264_resize_q75_h2_box_3.webp"
        title="设置环境变量 IPFS_PATH"
         height="264"
         width="610"
        loading="lazy"
    /></p>
<h4 id="初始化"><a href="#初始化" class="header-mark headerLink">初始化</a></h4>
<p>运行命令 <code>ipfs init</code> 进行初始化，这一步会初始化密钥对，并在刚刚指定的<code>IPFS_PATH</code>目录创建初始文件。</p>
<p>




    
        
        
        
        
    
<img
        
        src="/posts/tutorials/p2p/ipfs/tutorial/ipfs_init_hue0c94ec89459672a8c5cc644ff0765dd_18447_727x152_resize_q75_h2_box_3.webp"
        alt="/posts/tutorials/p2p/ipfs/tutorial/ipfs_init_hue0c94ec89459672a8c5cc644ff0765dd_18447_727x152_resize_q75_h2_box_3.webp"
        title="初始化"
         height="152"
         width="727"
        loading="lazy"
    /></p>
<h4 id="查看节点id信息"><a href="#查看节点id信息" class="header-mark headerLink">查看节点ID信息</a></h4>
<p>运行命令 <code>ipfs id</code> 即可查看自己IPFS节点ID信息，包含了节点ID、公钥、地址、代理版本、协议版本、支持的协议等信息</p>
<p>可以通过 <code>ipfs id 别人的ID</code>来查看别人的节点ID信息</p>
<h4 id="检查可用性"><a href="#检查可用性" class="header-mark headerLink">检查可用性</a></h4>
<p>通过显示的命令来检查可用性，这里使用<code>ipfs cat</code>命令来查看指定的<code>CID</code>对应的内容。</p>
<p>




    
        
        
        
        
    
<img
        
        src="/posts/tutorials/p2p/ipfs/tutorial/ipfs_init_hue0c94ec89459672a8c5cc644ff0765dd_18447_727x152_resize_q75_h2_box_3.webp"
        alt="/posts/tutorials/p2p/ipfs/tutorial/ipfs_init_hue0c94ec89459672a8c5cc644ff0765dd_18447_727x152_resize_q75_h2_box_3.webp"
        title="IPFS cat"
         height="152"
         width="727"
        loading="lazy"
    /></p>
<h4 id="开启守护进程"><a href="#开启守护进程" class="header-mark headerLink">开启守护进程</a></h4>
<p>运行下面命令开启守护进程</p>
<div class="highlight"><div class="chroma">
<div class="table-wrapper"><table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-powershell" data-lang="powershell"><span class="line"><span class="cl"><span class="n">ipfs</span> <span class="n">daemon</span>
</span></span></code></pre></td></tr></table></div>
</div>
</div><h3 id="获取文件夹"><a href="#获取文件夹" class="header-mark headerLink">获取文件(夹)</a></h3>
<p>IPFS获取文件的方式是隐式的，我们可以通过查看、下载等命令，告诉IPFS你要去获取我想要的文件</p>
<h4 id="查看文本"><a href="#查看文本" class="header-mark headerLink">查看文本</a></h4>
<p>查看文本使用 <code>ipfs cat</code>命令来进行，就如前面检查可用性的使用一样</p>
<h4 id="下载二进制"><a href="#下载二进制" class="header-mark headerLink">下载二进制</a></h4>
<p>对于图片、视频等文件，无法使用<code>cat</code>命令来查看（cat出来是一堆乱码），此时我们可以使用<code>ipfs get cid</code>的方式来将文件下载到本地。不过这样直接下载文件名会是指定的CID，一个长字符串不具有识别性，我们可以重定向到指定的文件，<code>ipfs get cid -o newname.png</code></p>
<p>




    
        
        
        
        
    
<img
        
        src="/posts/tutorials/p2p/ipfs/tutorial/ipfs_get_hub7496c85bb414641f3077f6cc733b39d_34008_1076x276_resize_q75_h2_box_3.webp"
        alt="/posts/tutorials/p2p/ipfs/tutorial/ipfs_get_hub7496c85bb414641f3077f6cc733b39d_34008_1076x276_resize_q75_h2_box_3.webp"
        title="IPFS get"
         height="276"
         width="1076"
        loading="lazy"
    /></p>
<h4 id="列出目录"><a href="#列出目录" class="header-mark headerLink">列出目录</a></h4>
<p>通过<code>ipfs ls</code>命令来列出一个目录</p>
<p>




    
        
        
        
        
    
<img
        
        src="/posts/tutorials/p2p/ipfs/tutorial/ipfs_ls_hu5ebba350e887d3e45522f22c53bbc550_42643_1085x191_resize_q75_h2_box_3.webp"
        alt="/posts/tutorials/p2p/ipfs/tutorial/ipfs_ls_hu5ebba350e887d3e45522f22c53bbc550_42643_1085x191_resize_q75_h2_box_3.webp"
        title="IPFS ls"
         height="191"
         width="1085"
        loading="lazy"
    /></p>
<h3 id="添加文件夹"><a href="#添加文件夹" class="header-mark headerLink">添加文件(夹)</a></h3>
<p>通过<code>ipfs add 文件名</code>命令来将文件添加到IPFS</p>
<p>如果需要添加文件夹，需要添加<code>-r</code>参数来使其递归处理</p>
<p>




    
        
        
        
        
    
<img
        
        src="/posts/tutorials/p2p/ipfs/tutorial/ipfs_add_hu1c96c226f6134ef6708ef949a5fca894_26053_1097x152_resize_q75_h2_box_3.webp"
        alt="/posts/tutorials/p2p/ipfs/tutorial/ipfs_add_hu1c96c226f6134ef6708ef949a5fca894_26053_1097x152_resize_q75_h2_box_3.webp"
        title="IPFS add"
         height="152"
         width="1097"
        loading="lazy"
    /></p>
<h2 id="相关概念"><a href="#相关概念" class="header-mark headerLink">相关概念</a></h2>
<p>在进行深一步学习之前，先让我们来看一下关于IPFS几个不得不知道的概念，这些概念是IPFS的基础组成部分，对后续的使用至关重要</p>
<h3 id="peer"><a href="#peer" class="header-mark headerLink">Peer</a></h3>
<p><strong>Peer</strong>是对等节点，因为IPFS是基于P2P技术实现的，所以没有服务器客户端这一说，每个人都同时是服务器和客户端，人人为我，我为人人。</p>
<h3 id="cid"><a href="#cid" class="header-mark headerLink">CID</a></h3>
<p><strong>内容标识符</strong>（CID）是一个用于指向IPFS中的内容的标签。它不指示内容存储在哪里，但它根据内容数据本身形成一种地址。无论它指向的内容有多大，CID都很短</p>
<p>详细内容见：<a href="https://docs.ipfs.io/concepts/content-addressing/" target="_blank" rel="noopener noreffer" class="post-link">IPFS官方文档：Content addressing and CIDs</a></p>
<p>在线的CID查看器：<a href="https://cid.ipfs.io/" target="_blank" rel="noopener noreffer" class="post-link">CID Inspector</a></p>
<h3 id="gateway"><a href="#gateway" class="header-mark headerLink">Gateway</a></h3>
<ul>
<li>IPFS官方提供的Gateway: <a href="https://ipfs.io/" target="_blank" rel="noopener noreffer" class="post-link">https://ipfs.io/</a></li>
<li>Cloudflare提供的IPFS Gateway服务：https://cf-ipfs.com</li>
<li>其他公开的Gateway列表：https://ipfs.github.io/public-gateway-checker/</li>
</ul>
<p><a href="https://www.cloudflare.com/distributed-web-gateway/" target="_blank" rel="noopener noreffer" class="post-link">https://www.cloudflare.com/distributed-web-gateway/</a></p>
<p>具体见：<a href="https://docs.ipfs.io/concepts/ipfs-gateway/" target="_blank" rel="noopener noreffer" class="post-link">IPFS文档：Gateway</a></p>
<h3 id="ipns"><a href="#ipns" class="header-mark headerLink">IPNS</a></h3>
<p>IPFS使用基于内容的寻址方式，简单说就是IPFS根据文件数据的Hash来生成CID，这个CID只与文件内容有关，这也就导致了如果我们修改这个文件的内容，这个CID也会改变。如果我们通过IPFS给别人分享文件，则每次更新内容时都需要给此人一个新链接。</p>
<p>为了解决这个问题，星际名称系统（IPNS）通过创建一个可以更新的地址来解决这个问题。</p>
<p>具体见：<a href="https://docs.ipfs.io/concepts/ipns/" target="_blank" rel="noopener noreffer" class="post-link">IPFS文档：IPNS</a></p>
<h3 id="ipld"><a href="#ipld" class="header-mark headerLink">IPLD</a></h3>
<p><a href="https://docs.ipfs.io/concepts/ipld/" target="_blank" rel="noopener noreffer" class="post-link">https://docs.ipfs.io/concepts/ipld/</a></p>
<h2 id="在ipfs部署网站"><a href="#在ipfs部署网站" class="header-mark headerLink">在IPFS部署网站</a></h2>
<p>既然IPFS宣称能够构建新一代分布式Web，那我们便想要把自己的网站部署到IPFS上去，一起体验一下去中心化、分布式的Web3.0技术</p>
<h3 id="将文件添加到ipfs中"><a href="#将文件添加到ipfs中" class="header-mark headerLink">将文件添加到IPFS中</a></h3>
<p>我使用的是Hugo静态网站生成器生成我的博客，生成的内容存放在<code>public</code>目录下，所以首先我需要将<code>public</code>目录及其里面的所有内容添加到IPFS中。</p>
<div class="highlight"><div class="chroma">
<div class="table-wrapper"><table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-powershell" data-lang="powershell"><span class="line"><span class="cl"><span class="c"># -r 参数代表递归添加</span>
</span></span><span class="line"><span class="cl"><span class="n">ipfs</span> <span class="n">add</span> <span class="n">-r</span> <span class="n">public</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c"># 实际运行效果</span>
</span></span><span class="line"><span class="cl"><span class="nb">PS </span><span class="n">D:</span><span class="p">\</span><span class="n">blog</span><span class="p">&gt;</span> <span class="n">ipfs</span> <span class="n">add</span> <span class="n">-r</span> <span class="n">public</span>
</span></span><span class="line"><span class="cl"><span class="n">added</span> <span class="n">QmZT5jXEi2HFVv8tzuDqULBaiEPc8geZFVjXxb9iAsBqbg</span> <span class="n">public</span><span class="p">/</span><span class="mf">404</span><span class="p">.</span><span class="py">html</span>
</span></span><span class="line"><span class="cl"><span class="n">added</span> <span class="n">QmcGDfkg6mcboba3MkNeamGQvRgdnHiD4HZhvCRwEnSdSj</span> <span class="n">public</span><span class="p">/</span><span class="n">CNAME</span>
</span></span><span class="line"><span class="cl"><span class="n">很长的滚屏后</span><span class="p">......</span>
</span></span><span class="line"><span class="cl"><span class="n">added</span> <span class="n">QmT61SS4ykbnt1ECQFDfX27QJdyhsVfRrLJztDvbcR7Kc1</span> <span class="n">public</span><span class="p">/</span><span class="n">tags</span>
</span></span><span class="line"><span class="cl"><span class="n">added</span> <span class="n">QmdoJ8BiuN8H7K68hJhk8ZrkFXjU8T9Wypi9xAyAzt2zoj</span> <span class="n">public</span>
</span></span><span class="line"><span class="cl"> <span class="mf">35.12</span> <span class="n">MiB</span> <span class="p">/</span> <span class="mf">35.12</span> <span class="n">MiB</span> <span class="p">[===========================================]</span> <span class="mf">100.00</span><span class="p">%</span>
</span></span></code></pre></td></tr></table></div>
</div>
</div><p>如果你不想看这么长的滚屏，只想要最后一个Hash，可以添加一个 <code>Q</code> （quiet） 参数</p>
<div class="highlight"><div class="chroma">
<div class="table-wrapper"><table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-powershell" data-lang="powershell"><span class="line"><span class="cl"><span class="nb">PS </span><span class="n">D:</span><span class="p">\</span><span class="n">blog</span><span class="p">\</span><span class="n">blog</span><span class="p">&gt;</span> <span class="n">ipfs</span> <span class="n">add</span> <span class="n">-rQ</span> <span class="n">public</span>
</span></span><span class="line"><span class="cl"><span class="n">QmdoJ8BiuN8H7K68hJhk8ZrkFXjU8T9Wypi9xAyAzt2zoj</span>
</span></span></code></pre></td></tr></table></div>
</div>
</div><h3 id="通过ipfs网关访问"><a href="#通过ipfs网关访问" class="header-mark headerLink">通过IPFS网关访问</a></h3>
<p>在刚刚添加完成的最后，名称为<code>public</code>的那串Hash便是public目录的CID，我们现在可以通过这个CID在IPFS网关上访问我们刚刚的添加的内容。</p>
<h4 id="本机网关访问"><a href="#本机网关访问" class="header-mark headerLink">本机网关访问</a></h4>
<p>我们先通过本机的IPFS网关来访问一下，看看有没有添加成功。注意这一步需要你本地已经开启了IPFS守护进程。</p>
<p>访问：<a href="http://localhost:8080/ipfs/QmdoJ8BiuN8H7K68hJhk8ZrkFXjU8T9Wypi9xAyAzt2zoj" target="_blank" rel="noopener noreffer" class="post-link">http://localhost:8080/ipfs/QmdoJ8BiuN8H7K68hJhk8ZrkFXjU8T9Wypi9xAyAzt2zoj</a></p>
<p>然后浏览器会自动进行跳转，可以看到能够正常访问我们的页面</p>
<p>




    
        
        
        
        
    
<img
        
        src="/posts/tutorials/p2p/ipfs/web/ipfs_local_web_huadb15ebe10d4db9e763e1c38076cb909_45426_1043x515_resize_q75_h2_box_3.webp"
        alt="/posts/tutorials/p2p/ipfs/web/ipfs_local_web_huadb15ebe10d4db9e763e1c38076cb909_45426_1043x515_resize_q75_h2_box_3.webp"
        title="IPFS local web"
         height="515"
         width="1043"
        loading="lazy"
    /></p>
<div class="details admonition note open">
        <div class="details-summary admonition-title">
            <i class="icon icon-pencil"></i>注意<i class="details-icon icon-angle-circled-right"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><p>你会发现浏览器地址栏的网址为一个另一个<strong>长字符串</strong>构成的域名</p>
<p>长字符串.ipfs.localhost:8080</p>
<p>这里的长字符串是IPFS中的另一个概念：IPLD</p>
</div>
        </div>
    </div>
<p>如果你的页面只能够显示内容，但是样式是错误的，如下图</p>
<p>




    
        
        
        
        
    
<img
        
        src="/posts/tutorials/p2p/ipfs/web/local_error_hub933175cd275d038d871d1d59177ba77_31148_799x326_resize_q75_h2_box_3.webp"
        alt="/posts/tutorials/p2p/ipfs/web/local_error_hub933175cd275d038d871d1d59177ba77_31148_799x326_resize_q75_h2_box_3.webp"
        title="样式错误"
         height="326"
         width="799"
        loading="lazy"
    /></p>
<p>这是因为使用的是<strong>绝对地址</strong>，我们需要使用<strong>相对地址</strong>的形式，如果你和我一样使用Hugo，那么只需要在你的配置文件中增加 <code>relativeURLs = true</code> 即可</p>
<h4 id="远程网关访问"><a href="#远程网关访问" class="header-mark headerLink">远程网关访问</a></h4>
<p>刚刚我们通过本机的IPFS网关成功访问到了IPFS中的网站，现在我们找一个公开的其他的IPFS网关来访问试一下</p>
<p>这里我选择IPFS官方维护的网关：https://ipfs.io，访问：https://ipfs.io/ipfs/QmdoJ8BiuN8H7K68hJhk8ZrkFXjU8T9Wypi9xAyAzt2zoj</p>
<p>需要注意的是，此时网站还只存在于我们本机上，其他IPFS网关从IPFS网络中找到我们的网站文件需要一段时间，我们需要保证此时IPFS守护进程不关闭并已经连接了成百上千的其他节点，这样有利于IPFS官方Gateway尽快找到我们。</p>
<p>经过多次刷新和焦急的等待后，终于有了显示</p>
<p>




    
        
        
        
        
    
<img
        
        src="/posts/tutorials/p2p/ipfs/web/ipfs_web_huc31d8cfbcc41ab9125f8980cf7f3d7c6_7419_664x89_resize_q75_h2_box_3.webp"
        alt="/posts/tutorials/p2p/ipfs/web/ipfs_web_huc31d8cfbcc41ab9125f8980cf7f3d7c6_7419_664x89_resize_q75_h2_box_3.webp"
        title="IPFS WEB"
         height="89"
         width="664"
        loading="lazy"
    /></p>
<h3 id="使用ipns进行映射"><a href="#使用ipns进行映射" class="header-mark headerLink">使用IPNS进行映射</a></h3>
<p>使用命令 <code>ipfs name publish CID</code> 来发布一个IPNS，这里可能需要等待一会</p>
<div class="highlight"><div class="chroma">
<div class="table-wrapper"><table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-powershell" data-lang="powershell"><span class="line"><span class="cl"><span class="nb">PS </span><span class="n">D:</span><span class="p">\</span><span class="n">blog</span><span class="p">\</span><span class="n">blog</span><span class="p">&gt;</span> <span class="n">ipfs</span> <span class="n">name</span> <span class="n">publish</span> <span class="n">QmdoJ8BiuN8H7K68hJhk8ZrkFXjU8T9Wypi9xAyAzt2zoj</span>
</span></span><span class="line"><span class="cl"><span class="n">Published</span> <span class="n">to</span> <span class="n">k51qzi5uqu5djhbknypxifn09wxhtf3y1bce8oriud1ojqz5r71mpu75rru520</span><span class="err">:</span> <span class="p">/</span><span class="n">ipfs</span><span class="p">/</span><span class="n">QmdoJ8BiuN8H7K68hJhk8ZrkFXjU8T9Wypi9xAyAzt2zoj</span>
</span></span></code></pre></td></tr></table></div>
</div>
</div><p>




    
        
        
        
        
    
<img
        
        src="/posts/tutorials/p2p/ipfs/web/ipns_web_hu28962914925ee0c2440453f343e921c2_9294_866x90_resize_q75_h2_box_3.webp"
        alt="/posts/tutorials/p2p/ipfs/web/ipns_web_hu28962914925ee0c2440453f343e921c2_9294_866x90_resize_q75_h2_box_3.webp"
        title="ipns web"
         height="90"
         width="866"
        loading="lazy"
    /></p>
<p>通过使用IPNS映射，后续我们可以不断更新网站内容。如果没有使用IPNS而是直接发布CID，那别人便无法访问最新的版本了</p>
<div class="details admonition note open">
        <div class="details-summary admonition-title">
            <i class="icon icon-pencil"></i>注意<i class="details-icon icon-angle-circled-right"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><p>如果使用了IPNS，需要备份节点的<code>私钥</code>和生成IPNS地址时生成的<code>Key</code></p>
<p>它们分别存储在你init时显示的目录下的<code>config</code>文件和<code>keystore</code>文件夹内</p>
</div>
        </div>
    </div>
<h3 id="解析域名"><a href="#解析域名" class="header-mark headerLink">解析域名</a></h3>
<p>IPNS不是在IPFS上创建可变地址的唯一方法，我们还可以使用<strong>DNSLink</strong>，它目前比IPNS<strong>快得多</strong>，还使用<strong>人类可读</strong>的名称。</p>
<p>例如我想要给刚刚发布在IPFS上的网站绑定<code>ipfs.zu1k.com</code>这个域名，那我就需要创建<code>_dnslink.ipfs.zu1k.com</code>的<strong>TXT</strong>记录</p>
<p>




    
        
        
        
        
    
<img
        
        src="/posts/tutorials/p2p/ipfs/web/dnslink_hu2066ae7cdfeed825f54764811fdc23f4_23865_1011x352_resize_q75_h2_box_3.webp"
        alt="/posts/tutorials/p2p/ipfs/web/dnslink_hu2066ae7cdfeed825f54764811fdc23f4_23865_1011x352_resize_q75_h2_box_3.webp"
        title="DNSLink"
         height="352"
         width="1011"
        loading="lazy"
    /></p>
<p>然后任何人都可以用 <code>/ipfs/ipfs.zu1k.com</code> 来找到我的网站了，访问<a href="http://localhost:8080/ipns/ipfs.zu1k.com" target="_blank" rel="noopener noreffer" class="post-link">http://localhost:8080/ipns/ipfs.zu1k.com</a></p>
<p>




    
        
        
        
        
    
<img
        
        src="/posts/tutorials/p2p/ipfs/web/ipfs_dnslink_web_hu33d8573f961b2198a8f9cce73fac7e04_29509_832x360_resize_q75_h2_box_3.webp"
        alt="/posts/tutorials/p2p/ipfs/web/ipfs_dnslink_web_hu33d8573f961b2198a8f9cce73fac7e04_29509_832x360_resize_q75_h2_box_3.webp"
        title="DNSLink Web"
         height="360"
         width="832"
        loading="lazy"
    /></p>
<p>详细文档见：<a href="https://docs.ipfs.io/concepts/dnslink/#publish-using-a-subdomain" target="_blank" rel="noopener noreffer" class="post-link">IPFS文档：DNSLink</a></p>
<h3 id="更新内容"><a href="#更新内容" class="header-mark headerLink">更新内容</a></h3>
<p>更新内容时，只需要再添加一次，然后重新发布IPNS，如果你是使用DNSLink的方式，还需要修改DNS记录</p>
<h2 id="底层技术"><a href="#底层技术" class="header-mark headerLink">底层技术</a></h2>
<h3 id="merkle有向无环图dag"><a href="#merkle有向无环图dag" class="header-mark headerLink">Merkle有向无环图（DAG）</a></h3>
<p>每个Merkle都是一个有向无环图 ，因为每个节点都通过其名称访问。每个Merkle分支都是其本地内容的哈希，它们的子节点使用它们的哈希而非完整内容来命名。因此，在创建后将不能编辑节点。这可以防止循环（假设没有哈希碰撞），因为无法将第一个创建的节点链接到最后一个节点从而创建最后一个引用。</p>
<p>对任何Merkle来说，要创建一个新的分支或验证现有分支，通常需要在本地内容的某些组合体（例如列表的子哈希和其他字节）上使用一种哈希算法。IPFS中有多种散列算法可用。</p>
<p>输入到散列算法中的数据的描述见 <a href="https://github.com/ipfs/go-ipfs/tree/master/merkledag" target="_blank" rel="noopener noreffer" class="post-link">https://github.com/ipfs/go-ipfs/tree/master/merkledag</a></p>
<p>具体见：<a href="https://docs.ipfs.io/concepts/merkle-dag/" target="_blank" rel="noopener noreffer" class="post-link">IPFS文档：Merkle</a></p>
<h3 id="分布式散列表dht"><a href="#分布式散列表dht" class="header-mark headerLink">分布式散列表DHT</a></h3>
<p>具体见：<a href="https://docs.ipfs.io/concepts/dht/" target="_blank" rel="noopener noreffer" class="post-link">IPFS文档：DHT</a></p>
<h2 id="上层应用"><a href="#上层应用" class="header-mark headerLink">上层应用</a></h2>
<p>IPFS作为一个文件系统，本质就是用来存储文件，基于这个文件系统的一些特性，有很多上层应用涌现出来。</p>
<p>




    
        
        
        
        
    
<img
        
        src="/posts/tutorials/p2p/ipfs/ipfs-applications-diagram_hu19aac670f6e619937c2c8cad6ce6f536_739482_2707x1227_resize_q75_h2_box_3.webp"
        alt="/posts/tutorials/p2p/ipfs/ipfs-applications-diagram_hu19aac670f6e619937c2c8cad6ce6f536_739482_2707x1227_resize_q75_h2_box_3.webp"
        title="基于IPFS的应用"
         height="1227"
         width="2707"
        loading="lazy"
    /></p>
<h2 id="filecoin"><a href="#filecoin" class="header-mark headerLink">Filecoin</a></h2>
<p>




    
        
        
        
        
    
<img
        
        src="/posts/tutorials/p2p/ipfs/filecoin_hu59116c23b2200775e35574249313ea8b_277953_1088x756_resize_q75_h2_box_3.webp"
        alt="/posts/tutorials/p2p/ipfs/filecoin_hu59116c23b2200775e35574249313ea8b_277953_1088x756_resize_q75_h2_box_3.webp"
        title="Filecoin"
         height="756"
         width="1088"
        loading="lazy"
    /></p>
<h2 id="基于ipfs构建应用"><a href="#基于ipfs构建应用" class="header-mark headerLink">基于IPFS构建应用</a></h2>
<p>IPFS提供了IPFS协议的<strong>Golang</strong>和<strong>JavaScript</strong>实现，可以非常方便的将IPFS集成到我们的应用当中，充分利用IPFS的各种优势。</p>
<h2 id="未来的期望"><a href="#未来的期望" class="header-mark headerLink">未来的期望</a></h2>
<p>对于P2P：https://t.zu1k.com/post/618818179793371136/%E5%85%B3%E4%BA%8Eresilio-sync</p>
<h2 id="一些问题"><a href="#一些问题" class="header-mark headerLink">一些问题</a></h2>
<h3 id="ipfs可以永久存储文件"><a href="#ipfs可以永久存储文件" class="header-mark headerLink">IPFS可以永久存储文件？</a></h3>
<p>很多人误认为IPFS可以永久存储文件，从使用的技术来讲的确更有利于永久存储内容，但是还需不断需要有人访问、Pin、传播该内容，否则待全网所有节点都将该内容数据GC掉，数据还是会丢失。</p>
<h3 id="ipfs是匿名的"><a href="#ipfs是匿名的" class="header-mark headerLink">IPFS是匿名的？</a></h3>
<p>有人认为P2P就是匿名的，就像Tor一样，就像以太坊一样。实际上绝大部分P2P应用都不是匿名的，IPFS也不是匿名的，所以当你在发布敏感信息的时候，需要保护好自己。IPFS目前还不支持Tor网络。</p>
<h3 id="ipfs速度快延迟低"><a href="#ipfs速度快延迟低" class="header-mark headerLink">IPFS速度快，延迟低？</a></h3>
<p>从理论上来讲，只要节点数量足够多，基于P2P技术的IPFS速度能够跑满你的带宽，延迟也有可能比中心化的Web低。但实际上，就目前情况而言，使用IPFS的人并不多，你链接的IPFS节点最多也就1000个左右（至少目前阶段我最多也就撑死连1000个以内），所以并不能达到理论的理想状态，所以现在IPFS的速度并不是很快，并且很少人访问的冷数据延迟很高，还有大概率找不到。</p>
<h3 id="ipfs是骗局filecoin是骗局"><a href="#ipfs是骗局filecoin是骗局" class="header-mark headerLink">IPFS是骗局，Filecoin是骗局？</a></h3>
<p>的确，目前有很多投机的人，他们想要通过销售所谓的IPFS矿机（其实就是普通的电脑接上大硬盘）来盈利，所以他们故意去混淆IPFS、Filecoin、比特币、区块链等概念，打着永久存储的伪概念，用区块链这个热点来欺骗啥都不懂的老人，这种行为非常无耻。</p>
<p>实际上，IPFS本身并不是骗局，基于IPFS产生的激励层Filecoin也不是骗局，从我的使用来看，任何人都<strong>无需</strong>特意去购买任何所谓的IPFS矿机，只需要在自己的电脑运行时，后台跑一个IPFS守护进程就可以了。不要被所谓的<strong>币</strong>冲昏了头脑。</p>
<h2 id="参考资料"><a href="#参考资料" class="header-mark headerLink">参考资料</a></h2>
<ul>
<li><a href="https://ipfs.io/" target="_blank" rel="noopener noreffer" class="post-link">IPFS官网</a></li>
<li><a href="https://docs.ipfs.io/" target="_blank" rel="noopener noreffer" class="post-link">IPFS文档</a></li>
<li><a href="https://blog.ipfs.io/" target="_blank" rel="noopener noreffer" class="post-link">IPFS博客</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E6%98%9F%E9%99%85%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener noreffer" class="post-link">维基百科：星际文件系统</a></li>
<li><a href="https://io-oi.me/tech/host-your-blog-on-ipfs/" target="_blank" rel="noopener noreffer" class="post-link">将博客部署到星际文件系统（IPFS）</a></li>
</ul>
<h2 id="资源分享"><a href="#资源分享" class="header-mark headerLink">资源分享</a></h2>
<ul>
<li>机械工业出版社294G原版PDF：<a href="https://ipfs.io/ipfs/QmZYDnPgTRs1MmBx9TPrADFV1K85sPSqLJhAShWayubu9c/" target="_blank" rel="noopener noreffer" class="post-link">/ipfs/QmZYDnPgTRs1MmBx9TPrADFV1K85sPSqLJhAShWayubu9c</a></li>
</ul>
]]></description></item></channel></rss>